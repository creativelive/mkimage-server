const fs = require('fs');
const {log, getDurationMilliseconds} = require('./logger')('cache');
const {AppError, ServerError} = require('./errors');
const path = require('path');
const request = require('request');
const crypto = require('crypto');
const sprintf = require('util').format;

/**
 * Util function used to generate cache filenames.
 */
function md5(str, callback) {
  return crypto.createHash('md5').update(str).digest('hex');
}

/**
 * Util function that uniquely-enough tags a filename to avoid collisions inside the working dir
 * both intra- and cross-process. We do so by appending the following suffix to the input string:
 * ".{pid}.{in-process-rolling-counter}"
 */
const MAX_INT = Math.pow(2, 53) - 1;
let counter = 0;
function tag(str) {
  const result = str + '.' + process.pid + '.' + ++counter;
  counter %= MAX_INT;
  return result;
}
/**
 * And its dual, untagging a string generated by tag().
 */
function untag(str) {
  let parts = str.split('.');
  parts.pop(); // Discard counter
  parts.pop(); // Discard pid
  return parts.join();
}

/**
 * Constructs a Cachedir instance that refers to a cache directory tree where downloaded raw image
 * assets as well as transformed assets are stored, as well as a working directory where in-flight
 * downloads and transforms stage their work until successful completion.
 */

class Cachedir {
  constructor(config) {
    config = config || {};
    this.cache_dir = config.cache_dir;
    this.work_dir = config.work_dir;
  }

  ensure_path(filename, callback) {
    fs.mkdir(path.dirname(filename), {recursive: true}, callback);
  }

  /**
   * Generates a cache path from filename string.
   * The path is generated using the first 4 characters of the filename.
   * E.g.: this_is_a_filename.txt will become - <cache_dir>/t/h/i/s/this_is_a_filename.txt
   *   where cache_dir, is the configured dir for caches.
   *
   * The callback has 2 params:
   *   string  - full path for the cached file
   *   boolean - if the cached file already exists or not
   */
  get_cached_path(filename, callback) {
    const file = path.basename(filename);
    const dir = file.substr(0, 4).split('').join('/'); // This builds the single-char dir tree.
    const dest = sprintf('%s/%s/%s', this.cache_dir, dir, file);

    fs.exists(dest, function (exists) {
      callback(dest, exists);
    });
  }

  /**
   * Generates a working path from filename string.
   * The callback has 2 params:
   *   string  - full path for the working file
   *   boolean - if the working file already exists or not
   */
  get_working_path(filename, extension, callback) {
    const workingFile = tag(path.basename(filename));
    const dest = sprintf('%s/%s', this.work_dir, workingFile) + (extension || '');

    fs.exists(dest, function (exists) {
      if (exists) {
        log.warn('Working file already exists: ' + dest);
      }
      callback(dest, exists);
    });
  }


  /**
   * Atomically promote a file in our working directory space into the stable cache directory tree.
   * The callback has 2 params:
   *   error  - for any fs failure
   *   string - promoted cache file path on success
   */
  promote_working_path_to_cache(workingPath, extension, callback) {
    // need to omit the extension before the untagging process
    let normalizedFile = extension ? workingPath.replace(new RegExp('\\' + extension + '$'), '') : workingPath;
    // untag the file so we get the normalized name that is consistent with how we store it in the cache
    normalizedFile = untag(path.basename(normalizedFile));
    this.get_cached_path(normalizedFile, function (dest, exists) {
      if (exists) {
        log.warn('Renaming working file over existing cache file: ' + dest);
      }
      // We need full target dir path in place before our atomic rename.
      fs.mkdir(path.dirname(dest), {recursive: true}, function (err) {
        if (err) {
          callback(new ServerError('unable to create cache directory', err));
          return;
        }
        // Atomically replace cache file with working file.
        fs.rename(workingPath, dest, function (err) {
          if (err) {
            callback(new ServerError('unable to rename cache file', err));
            return;
          }
          callback(null, dest);
        });
      });
    });
  }

  /**
   * Downloads a file from given url and saves it in cache dir; the working directory is used for in-flight download
   * and upon success the result is atomically moved into the stable cache dir tree. If a locally cached file already
   * exists, no download is done unless force=true in which case any existing cache file is overwritten if the
   * forced download succeeds.
   *
   * The cache file name is based on the md5 of the url.
   *
   * The callback has 2 params:
   *   error  - for any fs failure
   *   string - full path for the cache file
   */
  download(url, force, log, callback) {
    const self = this;

    // make sure we have a proper callback passed
    if (typeof callback !== 'function') {
      callback = force;
      force = false;
    }

    const hash = md5(url);
    self.get_cached_path(hash, function (output_file, exists) {
      if (exists && !force) {
        log.trace('Already downloaded. file=' + output_file);
        callback(null, output_file, exists);
      } else {

        // Helper function to avoid duplicate callback invocations.
        let done = false;

        function finish(err, outputFile) {
          if (!done) {
            done = true;
            callback(err, outputFile);
          } else {
            log.warn('Download finish invoked multiple times. err=' + err + ', file=' + outputFile);
          }
        }

        self.get_working_path(hash, null, function (workingPath, workingExists) {
          // Ensure full working dir path exists.
          self.ensure_path(workingPath, function (err) {
            if (err) {
              finish(new ServerError(err));
              return;
            }

            const start = process.hrtime();

            // Download target URL to working space and upon success, move it into cache dir tree.
            const writer = fs.createWriteStream(workingPath);
            writer.on('open', function (fd) {
              // Start download into target working file.
              const r = request(url);
              r.on('error', finish);
              r.on('response', function (res) {
                let dt = getDurationMilliseconds(start);
                if (res.statusCode !== 200) {
                  log.warn({duration: dt, url, statusCode: res.statusCode, file: workingPath}, `download failed with status code ${res.statusCode}`);

                  let statusCode = (res.statusCode === 404)? res.statusCode : 502;  // hide backing error for anything except 404

                  finish(new AppError(`download failed for "${url}"`, statusCode));
                  return;
                }
                log.info({duration: dt, url, statusCode: res.statusCode, file: workingPath}, 'download succeeded!');
                // Pipe response body through to target working file.
                r.pipe(writer);
              });
              writer.on('close', function () {
                log.trace('Done writing to file: ' + workingPath);

                // TODO: consider validating download file here? However, any errors result in this file being discarded.
                self.promote_working_path_to_cache(workingPath, null, callback);

              });
              writer.on('error', function (err) {
                log.warn({err, file: workingPath}, 'error piping download to file');
                finish(new ServerError('error saving download', err))
              })
            });

          });
        });

      }
    });
  }
}

exports.create = function(config) {
  return new Cachedir(config);
};
